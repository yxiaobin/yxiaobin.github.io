---
title: 数据结构实验之查找七：线性之哈希表
date: 2017-12-17 20:01:02
categories: 数据结构
---
Problem Description  
  
根据给定的一系列整数关键字和素数p,用除留余数法定义hash函数H(Key)=Key%p,将关键字映射到长度为p的哈希表中，用线性探测法解决冲突。重复关键字放在hash表中的同一位置。  
Input  
  
连续输入多组数据，每组输入数据第一行为两个正整数N(N <= 1500)和p(p >=
N的最小素数)，N是关键字总数，p是hash表长度<!-- more -->，第2行给出N个正整数关键字，数字间以空格间隔。  
Output  
  
输出每个关键字在hash表中的位置，以空格间隔。注意最后一个数字后面不要有空格。  
Example Input  
  
5 5  
21 21 21 21 21  
4 5  
24 15 61 88  
4 5  
24 39 61 15  
5 5  
24 39 61 15 39  
Example Output  
  
1 1 1 1 1  
4 0 1 3  
4 0 1 2  

4 0 1 2 0

思路：

与裸哈希表相比，难点在于“相同元素的位置是相同的”。我做这道题的想法是对于未出现过的数据进行Hash，并对Hash过的数据进行标记，队友后面的数据如果已经Hash过了，直接是的与前面所记录的数据相同，为出现过的进行Hash，详细看代码

    
    
    #include <iostream>
    #include<cstring>
    #include <cstdio>
    using namespace std;
    int n,p,num[1600],key[1600], a[1000100];//标记hash数组，输出记录数组，标记数据数组
    void Hash(int x,int id)
    {
        int Org = x;
        x = x%p;
        if(!num[x])//未发生冲突的时候
        {
            num[x] = 1;
            key[id] = x;
        }
        else//解决冲突
        {
            for(int i=1; i<1000; i++)
            {
                int  z = i+Org;//初始值的K倍
                x =z%p;
                if(!num[x])
                {
                    num[x] = 1;
                    key[id] = x;
                    break;
                }
            }
        }
    }
    int main()
    {
        while(cin>>n>>p)
        {
            int  x;
            memset(num,0,sizeof(num)); //标记是否冲突用的
            memset(a,0,sizeof(a)); //标记是否是重复数据，这个数组需要开大
            for(int i=0; i<n; i++)
            {
                cin>>x;
                if(a[x]==0)//  第一次出现该数据
                {
                    a[x] = i+1; //对所有的数据进行相同规则的赋值，这样有利于之后对重复出现的数据进行复制
                    Hash(x,i);
                }
                else//此时数据x已经不是第一次出现了
                {
                    key[i]=key[a[x]-1]; //出现当前x的变量i，此时的 key[i] 与 a[x]-1对应的 key[a[x]-1] 相同
                }
            }
            for(int i=0;i<n;i++)
            {
                printf("%d%c",key[i],i==n-1?'\n':' ');
            }
        }
    }
    

  
  

