---
title: 数据结构实验之图论八：欧拉回路
date: 2017-06-25 19:23:17
categories: 数据结构
---
  
  
在哥尼斯堡的一个公园里，有七座桥将普雷格尔河中两个岛及岛与河岸连接起来。  
  
  
  
能否走过这样的七座桥，并且每桥只走一次？瑞士数学家欧拉最终解决了这个问题并由此创立了拓扑学。欧拉通过对七桥问题的研究，不仅圆满地回答了哥尼斯堡七桥问题，并证明了更为广泛的有关一笔画的三条结论，人们通常称之为欧拉定理。对于一个连通图，通常把从某结点出发一笔画成所经过的路线叫做欧拉路。人们又通常<!-- more -->把一笔画成回到出发点的欧拉路叫做欧拉回路。具有欧拉回路的图叫做欧拉图。  
  
你的任务是：对于给定的一组无向图数据，判断其是否成其为欧拉图？  
Input  
连续T组数据输入，每组数据第一行给出两个正整数，分别表示结点数目N(1 < N <=
1000)和边数M；随后M行对应M条边，每行给出两个正整数，分别表示该边连通的两个结点的编号，结点从1～N编号。  
Output  
若为欧拉图输出1，否则输出0。  
Example Input  
  
1  
6 10  
1 2  
2 3  
3 1  
4 5  
5 6  
6 4  
1 4  
1 6  
3 4  
3 6  
  
Example Output  
  
1  
  
Hint  

如果无向图连通并且所有结点的度都是偶数，则存在欧拉回路，否则不存在。  

思路 ： 做题的要点 就在 Hint 里面。

证明所有节点度数为偶数，并且 这是一个连通图

一个来自只会用 bfs 判断连通的 的渣渣的代码  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    using namespace std;
    int map[1020][1020];
    int vis[1020];
    int n,m;
    int bfs(int x)
    {
        vis[x]=1;
        queue<int >q;
        q.push(x);
        while (!q.empty())
        {
            int nx=q.front();
            q.pop();
            if(nx==n)
            {
                return 1;
            }
            for(int i=1;i<=n;i++)
            {
                if(map[nx][i] && vis[i]==0)
                {
                    vis[i]=1;
                    q.push(i);
                }
            }
        }
        return 0;
    }
    int main ()
    {
        int t,i,j,a,b;
        int flag;
        cin >>t;
        while(t--)
        {
            cin >>n>>m;
            memset(map,0,sizeof(map));
            memset(vis,0,sizeof(vis));
            for(i=0;i<m;i++)
            {
                cin >>a>>b;
                map[a][b]=map[b][a]=1;
            }
            flag=1;
            int ans;
            for(i=1;i<=n;i++)
            {
                ans=0;
                for(j=1;j<=n;j++)
                {
                    if(map[i][j]==1)
                    {
                        ans++;
                    }
                }
                if(ans%2==1)
                    {
                        flag=0;
                        break;
                    }
            }
            if(flag && bfs(1))
            {
                printf("1\n");
            }
            else
            printf("0\n");
    
        }
        return 0;
    
    }
    

  
  

