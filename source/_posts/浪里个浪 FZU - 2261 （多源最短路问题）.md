---
title: 浪里个浪 FZU - 2261 （多源最短路问题）
date: 2017-07-25 20:15:27
categories: 数据结构文章标签
---
  
TonyY是一个喜欢到处浪的男人，他的梦想是带着兰兰姐姐浪遍天朝的各个角落，不过在此之前，他需要做好规划。  
  
现在他的手上有一份天朝地图，上面有n个城市，m条交通路径，每条交通路径都是单行道。他已经预先规划好了一些点作为旅游的起点和终点，他想选择其中一个起点和一个终点，并找出从起点到终点的一条路线亲身体验浪的过程。但是他时间有限，所以想选择耗时最小的，你能告诉他最小的耗时是多少吗？ <!-- more --> 
Input  
  
包含多组测试数据。  
  
输入第一行包括两个整数n和m，表示有n个地点，m条可行路径。点的编号为1 - n。  
  
接下来m行每行包括三个整数i, j, cost，表示从地点i到地点j需要耗时cost。  
  
接下来一行第一个数为S，表示可能的起点数，之后S个数，表示可能的起点。  
  
接下来一行第一个数为E，表示可能的终点数，之后E个数，表示可能的终点。  
  
0<S, E≤n≤100000，0<m≤100000，0<cost≤100。  
Output  
  
输出他需要的最短耗时。  
Sample Input  
  
4 4  
1 3 1  
1 4 2  
2 3 3  
2 4 4  
2 1 2  
2 3 4  
  
Sample Output  
  

1

要点：  

多源最短路问题的重点： 将所有的起点全部通过一个自己添加的初始点（比如 ‘0’点） 且0点到所有的起点的距离全部为0，然后找从新起点到所有重点的最短路，

通过一遍SPFA可以吧所有点的最短距离全部找到，只需要到最后做一遍比较就好了  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <vector>
    #include <queue>
    #include <algorithm>
    #define inf 0x3f3f3f3f
    using namespace std;
    struct node
    {
        int id;
        int wi;
    } h;
    int ed;
    int dist[100100];//储存从起始点到每个点的距离
    int vis[100100];//访问变量
    int n,m,s,e;
    vector<node>v[200100];
    void spfa()
    {
        memset(vis,0,sizeof(vis));
        for(int i=0; i<=n+1; i++) dist[i]=inf;//初始距离数组为无穷大
        dist[0]=0;
        queue<int>q;
        vis[0]=1;
        q.push(0);
        while(!q.empty())
        {
            int x=q.front();
            q.pop();
            for(int i=0; i<v[x].size(); i++)
            {
                int id=v[x][i].id;
                int wi=v[x][i].wi;
                if(dist[id]>dist[x]+wi)
                {
                    dist[id]=dist[x]+wi;
                }
                if(!vis[id])
                {
                    q.push(id);
                    vis[id]=1;
                }
            }
        }
    }
    int main ()
    {
        int i;
        int x,y,z;
        while(~scanf("%d %d",&n,&m))
        {
            for(i=0; i<m; i++)
                v[i].clear();
            for(i=0; i<m; i++)
            {
                scanf("%d %d %d",&x,&y,&z);
                h.id=y;
                h.wi=z;
                v[x].push_back(h);
            }
            scanf("%d",&s);
            for(i=0; i<s; i++)
            {
                scanf("%d",&x);
                h.id=x;
                h.wi=0;
                v[0].push_back(h);
            }
            spfa();
            scanf("%d",&e);
            int min=inf;
            for(i=0; i<e; i++)
            {
                scanf("%d",&ed);
                if(min>dist[ed])
                {
                    min=dist[ed];
                }
            }
            cout<<min<<endl;
        }
    }
    

  

  

