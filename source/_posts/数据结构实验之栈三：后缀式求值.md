---
title: 数据结构实验之栈三：后缀式求值
date: 2017-06-01 19:49:42
categories: 数据结构文章标签
---
数据结构实验之栈三：后缀式求值  
Time Limit: 1000MS Memory Limit: 65536KB  
Problem Description  
对于一个基于二元运算符的后缀表示式（基本操作数都是一位正整数），求其代表的算术表达式的值。  
Input  
输入一个算术表达式的后缀式字符串，以‘#’作为结束标志。  
Output  
求该后缀式所对应的算术表达式的值，并输出之<!-- more -->。  
Example Input  
  
59*684/-3*+#  
  
Example Output  
  
57  

提示 ：后缀表达式的计算 抓住最重要的就是 运算顺序根据后缀表达式中出现的顺序。 即
出现了一个运算符号，则该运算符号之前的两个数据必定进行一次运算。我们可以用一个栈来储存运算的进度。没有遇到运算符号的时候，把数据存入栈中，当遇到一个运算符号的时候从栈中提取栈顶和次栈顶的数字进行该运算符的操作，并且把新运算得到的数据再次存入栈中。这样运算的话，到最后栈中只会剩下唯一的一个元素，那个元素就是答案  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <stack>
    #include<algorithm>
    using namespace std;
    int a[150];
    int main()
    {
        stack  <int> q;
        int n,i,j,k;
        char s[150];
        cin >> s;
        n=strlen(s);
        int sum=0;
        for(i=0; i<n; i++)
        {
            if(s[i]>='0' && s[i]<='9')
            {
                q.push(s[i]-'0');
            }
            else   if(s[i]=='+')
            {
                j=q.top();
                q.pop();
                k=q.top();
                q.pop();
                sum=k+j;
                q.push(sum);
            }
            else if(s[i]=='-')
            {
                j=q.top();
                q.pop();
                k=q.top();
                q.pop();
                sum=k-j;
                q.push(sum);
            }
            else if(s[i]=='*')
            {
                j=q.top();
                q.pop();
                k=q.top();
                q.pop();
                sum=k*j;
                q.push(sum);
            }
            else  if(s[i]=='/')
            {
                j=q.top();
                q.pop();
                k=q.top();
                q.pop();
                sum=k/j;
                q.push(sum);
            }
            else
            {
                break;
            }
        }
        cout << q.top();
        return 0;
    }
    

  
  

