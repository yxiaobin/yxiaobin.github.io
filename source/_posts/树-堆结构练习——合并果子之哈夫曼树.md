---
title: 树-堆结构练习——合并果子之哈夫曼树
date: 2017-06-25 20:43:03
categories: 数据结构
---
Problem Description  
在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。  
每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所消耗体力之和。  
因为还要花大力气把这些果子搬回家，所以多多<!-- more -->在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。  
例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。  
  
Input  
第一行是一个整数n(1<=n<=10000),表示果子的种类数。第二行包含n个整数，用空格分隔，第i个ai(1<=ai<=20000)是第i个果子的数目。  
  
Output  
输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于2^31。  
  
Example Input  
  
3  
1 2 9  
  
Example Output  
  
15  

  

最小堆，或者是优先队列

如果真的看不懂，不要照着代码抄，放一放，过段时间，跟据自己的理解重新敲，现在放上优先队列的做法，过段时间在放最小堆的做法，希望大家监督（毕竟，我太渣，最小堆还不熟）  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    #include <algorithm>
    using namespace std;
    int main ()
    {
        int n,i,j;
         priority_queue<int , vector<int>, greater<int> >q;//优先队列，默认的是最大堆，这个是最小堆
        cin >>n;
        for(i=0;i<n;i++)
        {
            cin >>j;
            q.push(j);
        }
        int sum=0,ans;
        int a,b;
        while (!q.empty())
        {
            a=q.top();
            q.pop();
            if(q.empty())
             break;
            b=q.top();
            q.pop();
            ans=a+b;
            sum+=ans;
            q.push(ans);
        }
        cout <<sum<<endl;
        return 0;
    
    }
    

  
  

