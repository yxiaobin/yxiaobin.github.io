---
title: 图的深度遍历
date: 2017-06-03 20:41:16
categories: 数据结构文章标签
---
图的深度遍历  
Time Limit: 1000MS Memory Limit: 65536KB  
Problem Description  
请定一个无向图，顶点编号从0到n-1，用深度优先搜索(DFS)，遍历并输出。遍历时，先遍历节点编号小的。  
Input  
输入第一行为整数n（0 < n < 100），表示数据的组数。 对于每组数据，第一行是两个整数k,m（0 ＜ k ＜ 100，<!-- more -->0 ＜ m ＜
k*k），表示有m条边，k个顶点。 下面的m行，每行是空格隔开的两个整数u，v，表示一条连接u，v顶点的无向边。  
Output  
输出有n行，对应n组输出，每行为用空格隔开的k个整数，对应一组数据，表示DFS的遍历结果。  
Example Input  
  
1  
4 4  
0 1  
0 2  
0 3  
2 3  
  
Example Output  
  
0 1 2 3  

思考： dfs 是不同与 bfs 的 dfs
又叫做深度优先搜索，他时按深度搜索，即找到一条路直接走到黑，走到最后没路后，在往上返回到还有另一条路的最近的一个点，按照下一个点在进行深度搜索，所以，这就需要运用递归调用来实现dfs了。  

  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    #include <algorithm>
    using namespace std;
    int m,k,t,p;
    int map[200][200];
    int vis[200];
    void dfs(int x)
    {
          if(x==0)  printf("0");
          else  printf(" %d",x);
          for(int i=0;i<k;i++)
          {
            if(!vis[i] && map[x][i]==1)
            {
                vis[i]=1;
                dfs(i);
            }
          }
    }
    int main ()
    {
        int n,i,x,y;
        scanf("%d",&n);
        while(n--)
        {
            memset(map,0,sizeof(map));
            memset(vis,0,sizeof(vis));
            scanf("%d %d",&k,&m);
            for(i=0;i<m;i++)
            {
                scanf("%d %d",&x,&y);
                map[x][y]=map[y][x]=1;
            }
            vis[0]=1;
            dfs(0);
            printf("\n");
        }
    
    }
    

  

