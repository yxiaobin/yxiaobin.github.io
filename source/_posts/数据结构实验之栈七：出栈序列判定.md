---
title: 数据结构实验之栈七：出栈序列判定
date: 2017-05-31 10:14:07
categories: 数据结构文章标签
---
数据结构实验之栈七：出栈序列判定  
Time Limit: 30MS Memory Limit: 1000KB  
Submit Statistic Discuss  
Problem Description  
  
给一个初始的入栈序列，其次序即为元素的入栈次序，栈顶元素可以随时出栈，每个元素只能入栈依次。输入一个入栈序列，后面依次输入多个序列，请判断这些序列是否为所给入栈序列合法的出栈序列<!-- more -->。  
例如序列1，2，3，4，5是某栈的压入顺序，序列4，5，3，2，1是该压栈序列对应的一个出栈序列，但4，3，5，1，2就不可能是该序列的出栈序列。假设压入栈的所有数字均不相等。  
Input  
  
第一行输入整数n(1<=n<=10000)，表示序列的长度。  
第二行输入n个整数，表示栈的压入顺序。  
第三行输入整数t（1<=t<=10）。  
后面依次输入t行，每行n个整数，表示要判断的每一个出栈序列。  
Output  
  
对应每个测试案例输出一行，如果由初始入栈序列可以得到该出栈序列，则输出yes，否则输出no。  
Example Input  
  
5  
1 2 3 4 5  
2  
4 5 3 2 1  
4 3 5 1 2  
Example Output  
  
yes  

no

题意：给定一个数组a作为压栈序列，判断以一个给定的数组b作为出栈序列，判断是否是a的一个出栈序列。（因为题意中的随时出栈使得出栈序列可以有很多种）。

思路：把给定的出栈序列作为目标，逐个和压栈序列进行匹配，观察是否可以满足要求： 首选 b【0】在 a数组中进行匹配，倘若a【i】=b【0】 那么把a【0】到
a【i-1】全部压栈，然后在从i+1 开始 匹配 b【1】， 倘若找到了一个a【k】＝b【1】则把a【i+1】到
a【k-1】全部压栈；倘若没有找到则把b【1】
和栈顶元素进行比较，如果相同，咋把栈顶元素删除，并且继续寻找b【2】，若果不相同，则直接退出循环，输出no。按照这个规则一直找到b【n-1】
如果找到最后，栈恰好为空的时候输出yes。

    
    
    #include <stdio.h>
    #include <string.h>
    #include <algorithm>
    #include <stack>
    using namespace std;
    int a[15000], b[15000];
    int main ()
    {
        int n,i,j,t;
        scanf("%d",&n);
        for(i=0; i<n; i++)
            scanf("%d",&a[i]);
        scanf("%d",&t);
        while (t--)
        {
            for(i=0; i<n; i++)
                scanf("%d",&b[i]);
            stack <int > q;
            int flag=1;
            j=0;
            for(i=0; i<n; i++)
            {
                while (a[j]!=b[i] && j<=n-1)
                {
                    q.push(a[j]);
                    j++;
                }
                if(a[j]==b[i])
                {
                    j++;
                    continue;
                }
                else if(b[i]==q.top())
                {
                    q.pop();
                    continue;
                }
                else
                {
                    flag=0;
                    break;
                }
            }
            if(q.empty() && flag==1) printf("yes\n");
            else  printf("no\n");
    
    
        }
    }
    

  
  

