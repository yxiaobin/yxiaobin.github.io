---
title: 小明の魔法计划（最长倍数子序列）
date: 2017-07-24 21:07:20
categories: 数据结构文章标签
---
Problem Description  
  
在一个遥远的数学魔法国度，小明在学习一个魔法，这个魔法需要一些施法材料，所幸的是施法材料已经准备好了，下一步就是建立魔法阵了，每一个施法材料都有一个特性值，表示为一个大于1小于10
^
7的整数，当且仅当一个材料的特性值是另一个材料的特性值的倍数的时候，他们才可以建立法力连接。比如说，一个特性值为6和一个特性值为9的施法材料是不可以建立法力连接的，<!-- more -->而一个特性值为9和一个特性值为18的材料是可以建立法力连接的，值得注意的是法力连接是双向的。一个稳定的魔法阵要求属于这个法阵的材料之间不存在任何两个不直接连接的施法材料，比如说由(1,3,9)组成的魔法阵是稳定的，而(3,6,9)组成的魔法阵是不稳定的，因为值为6和值为9的材料无法建立连接。一个魔法阵的威力定义为这个法阵需要的材料的个数。  
现在小明已经收集到了一些材料，他想要知道在知道他收集的材料的特性值的前提下，能建立的最大威力的魔法阵的消耗材料的数量是多少。  
Input  
  
首先一个整数T，代表数据组数(T<=80)  
对于每一组数据，第一行是一个整数n，代表小明收集的施法材料的数量(1 < = n < = 1000)  
接下来一行一个有n个数，以空格隔开，分别代表n个施法材料的特性值，每个数1 < = a < = 10 ^ 7  
具体见样例  
Output  
  
每组数据输出一行一个整数，代表最大威力的魔法阵的需要的材料的个数  
Example Input  
  
2  
5  
1 2 4 8 16  
8  
12 24 1 2 4 8 72 16  
  
Example Output  
  
5  
6  
  
Hint  
  

魔法阵不一定是矩阵，施法材料可以随意摆放。

思路：

1\. 所有的数据全部有倍数关系，若a，b，c 互为倍数，则有 a是b的倍数，b是c 的倍数.

2\. 将整个数组从大到小排序，然后，仿照找最长上升子序列，找最长倍数子序列

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <stack>
    #include <algorithm>
    using namespace std;
    int a[12000];
    int dp[1200];
    int cmp (int x, int y)
    {
        return x>y;
    }
    int main()
    {
        int t, n, i, j;
        scanf("%d",&t);
        while(t--)
        {
            scanf("%d",&n);
            for(i=0; i<n; i++)
            {
                scanf("%d",&a[i]);
            }
            sort(a,a+n,cmp);
            dp[0]=1;
            for(i=1; i<n; i++)
            {
                dp[i]=1;
                for(j=0; j<i; j++)
                {
                    if(dp[j]>=dp[i] && a[j]%a[i]==0)
                    {
                        dp[i]=dp[j]+1;
                    }
                }
            }
            int max=-123456789;
            for(i=0; i<n; i++)
            {
                if(dp[i]>max)
                {
                    max=dp[i];
                }
            }
            printf("%d\n",max);
        }
    
    }
    

  
  

  

