---
title: HDU 1495 非常可乐
date: 2017-07-22 10:29:48
categories: 数据结构文章标签
---
大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N
毫升和M 毫升 可乐的体积为S （S<101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且
S==N+M，101＞S＞0，N<!-- more -->＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出"NO"。  
Input  
三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以"0 0 0"结束。  
Output  
如果能平分的话请输出最少要倒的次数，否则输出"NO"。  
Sample Input  
  
7 4 3  
4 1 3  
0 0 0  
  
Sample Output  
  
NO  

3

    
    
    // main函数里面有一个处理 使得三个“容器”容量大小的关系为S>n>m。这样的话，满足的条件一定是最后一个容器的量为0，前2个平分
    //坑点之一是如果输入的体积Ｓ为奇数的话，那么他一定不能平分到两个容器里。
    //不难想象，３个杯子共有６种到法（1到２，　１到３，２到１，２到３，３到１，３到２　）
    //每种到法都有两种结果（以１到２为例：１种的全部到进２中，１把２倒满后１种还有剩余）
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    #include <algorithm>
    using namespace std;
    int flag;
    int v,n,m;
    int vis[120][120][120];
    struct node
    {
        int x,y,z;
        int step;
    } a,b;
    void bfs()
    {
        queue<struct node>q;
        a.x=v;
        a.y=0;
        a.z=0;
        a.step=0;
        vis[a.x][a.y][a.z]=1;
        q.push(a);
        while(!q.empty())
        {
            b=q.front();
            q.pop();
            if(b.z==0 && b.y==b.x && b.y+b.x==v)  //实现的条件
            {
                flag=1;
                cout<<b.step<<endl;
                return ;
            }
            if(b.x!=0)/*ｓ向n m里面到*/
            {
                if(b.x > n-b.y)/*因为容器里面可能有一定量的可乐,所以要明确如何表示还能往该容器里面到多少体积的可乐*/
                {
                    a.x=b.x-n+b.y;
                    a.y=n;
                    a.z=b.z;
                    a.step=b.step+1;
                }
                else
                {
                    a.x=0;
                    a.y=b.y+b.x;
                    a.z=b.z;
                    a.step=b.step+1;
                }
                if(!vis[a.x][a.y][a.z])
                {
                    vis[a.x][a.y][a.z]=1;
                    q.push(a);
                }
                if(b.x > m-b.z)
                {
                    a.x=b.x-m+b.z;
                    a.y=b.y;
                    a.z=m;
                    a.step=b.step+1;
                }
                else
                {
                    a.x=0;
                    a.y=b.y;
                    a.z=b.x+b.z;
                    a.step=b.step+1;
                }
                if(!vis[a.x][a.y][a.z])
                {
                    vis[a.x][a.y][a.z]=1;
                    q.push(a);
                }
            }
            if(b.y!=0)//ｎ向ｓ　ｍ里面到
            {
                if(b.y > v-b.x)
                {
                    a.x=v;
                    a.y=b.y-v+b.x;
                    a.z=b.z;
                    a.step=b.step+1;
                }
                else
                {
                    a.x=b.x+b.y;
                    a.y=0;
                    a.z=b.z;
                    a.step=b.step+1;
                }
                if(!vis[a.x][a.y][a.z])
                {
                    vis[a.x][a.y][a.z]=1;
                    q.push(a);
                }
    
                if(b.y > m-b.z)
                {
                    a.x=b.x;
                    a.y=b.y-m+b.z;
                    a.z=m;
                    a.step=b.step+1;
                }
                else
                {
                    a.x=b.x;
                    a.y=0;
                    a.z=b.z+b.y;
                    a.step=b.step+1;
                }
                if(!vis[a.x][a.y][a.z])
                {
                    vis[a.x][a.y][a.z]=1;
                    q.push(a);
                }
    
            }
            if(b.z!=0)/*m向n,s里面到*/
            {
                if(b.z > v-b.x)
                {
                    a.x=v;
                    a.y=b.y;
                    a.z=b.z-v+b.x;
                    a.step=b.step+1;
                }
                else
                {
                    a.x=b.x+b.z;
                    a.y=b.y;
                    a.z=0;
                    a.step=b.step+1;
                }
                if(!vis[a.x][a.y][a.z])
                {
                    vis[a.x][a.y][a.z]=1;
                    q.push(a);
                }
    
                if(b.z > n-b.y)
                {
                    a.x=b.x;
                    a.y=n;
                    a.z=b.z-n+b.y;
                    a.step=b.step+1;
                }
                else
                {
                    a.x=b.x;
                    a.y=b.y+b.z;
                    a.z=0;
                    a.step=b.step+1;
                }
                if(!vis[a.x][a.y][a.z])
                {
                    vis[a.x][a.y][a.z]=1;
                    q.push(a);
                }
            }
        }
    
    }
    int main ()
    {
        while (cin>>v>>n>>m)
        {
            flag=0;
            if(n==0 && m==0 && v==0) break;
            if(n<m)
            {
                int t=n;
                n=m;
                m=t;
            }
            if(v%2 != 0)
                cout<<"NO"<<endl;
            else
            {
                memset(vis,0,sizeof(vis));
                bfs();
                if(!flag)
                cout<<"NO"<<endl;
            }
    
        }
        return 0;
    }
    

  
  

