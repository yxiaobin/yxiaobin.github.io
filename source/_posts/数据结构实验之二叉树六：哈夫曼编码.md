---
title: 数据结构实验之二叉树六：哈夫曼编码
date: 2017-06-25 22:17:03
categories: 数据结构
---
Problem Description  
  
字符的编码方式有多种，除了大家熟悉的ASCII编码，哈夫曼编码(Huffman
Coding)也是一种编码方式，它是可变字长编码。该方法完全依据字符出现概率来构造出平均长度最短的编码，称之为最优编码。哈夫曼编码常被用于数据文件压缩中，其压缩率通常在20%～90%之间。你的任务是对从键盘输入的一个字符串求出它的ASCII编码长度和哈夫曼编码长度的比值<!-- more -->。  
Input  
  
输入数据有多组，每组数据一行，表示要编码的字符串。  
Output  
  
对应字符的ASCII编码长度la，huffman编码长度lh和la/lh的值(保留一位小数)，数据之间以空格间隔。  
Example Input  
  
AAAAABCD  
THE_CAT_IN_THE_HAT  
Example Output  
  
64 13 4.9  

144 51 2.8

虽然 离散已经结课了，没有挂科，但不代表所有的概念都会。好吧，我把最小生成树
和最优二叉树搞混了，在这里谢谢学霸旋给我指出我的错误，并且不倦的告诉我最优二叉树的过程，并且掏出笔记本给我找到了离散的一个例题。不夸了，再夸就上天了…………容易飘，还拽不下来。

哈夫曼编码的长度 等于 权值乘以他的路径长度，算总和就好了（或者说，就是队列里面所有你累积的和那个就是哈夫曼编码的长度）。

STL 的 优先队列 真的好用多了，最小堆什么的 屎吧 O(∩_∩)O哈哈~

  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    #include <algorithm>
    using namespace std;
    int main ()
    {
        char s[15000];
        int num[300];
        int n,i;
        while (cin >>s)
        {
            n=strlen(s);
            memset(num,0,sizeof(num));
            int sum= n*8;
            priority_queue<int,vector<int>, greater<int> >q;
            for(i=0; i<n; i++)
            {
                num[s[i]]++;
            }
            for(i=0;i<250;i++)
            {
                if(num[i])
                {
                    q.push(num[i]);
                }
            }
            int ans=0;
            while(!q.empty())
            {
                int x=q.top();
                q.pop();
                if (!q.empty())
                {
                    int y=q.top();
                    q.pop();
                    int s=x+y;
                    q.push(s);
                    ans+=s;
                }
            }
            printf("%d %d %.1lf\n",sum,ans,(double)sum/ans);
        }
    
    }
    

  

