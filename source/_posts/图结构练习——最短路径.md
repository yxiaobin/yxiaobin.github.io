---
title: 图结构练习——最短路径
date: 2017-06-26 20:18:56
categories: 数据结构
---
Problem Description  
给定一个带权无向图，求节点1到节点n的最短路径。  
  
Input  
输入包含多组数据，格式如下。  
第一行包括两个整数n m，代表节点个数和边的个数。(n<=100)  
剩下m行每行3个正整数a b c，代表节点a和节点b之间有一条边，权值为c。  
  
Output  
每组输出占一行，仅输出从1到n的最短路径权值。（保证最短路径存在） <!-- more --> 
  
Example Input  
  
3 2  
1 2 1  
1 3 1  
1 0  
  
Example Output  
  
1  

0

算法一 弗洛利达算法（Fory 算法）

这个算法，还是比较容易懂得 简单点说 就是 暴力！！（毕竟，三重循环嘛）。

利用矩阵存路径 ，首选初始化地图 map[i][i]=0, map[i][j]=INF（无穷大）， 然后 把存在的路更新成他们的距离。

然后 三重循环的意思是 i点到k点的距离 于 i先到j，j再到k 的距离之和 进行比较 ，如果后者小，那么 更新 i到k的距离 为小的那个。

三重循环跑一边之后，ok！！！，整个地图所有的最短路已经全部更新到map 里了。你可以尽情的取了…………。

不过 这个算法 代价 耗时啊，，我相信，竞赛里面会超时超的怀疑人生。  

  

    
    
    #include <stdio.h>
    #include <string.h>
    #define INF 0x3f3f3f
    int map[2333][2333];
    void Fory(int n)
    {
    	int i,j,k;
    	for(i=0;i<=n;i++)
    	{
    		for(j=0;j<=n;j++)
    		{
    			for(k=0;k<=n;k++)
    			{
    				if(map[j][k]>map[j][i]+map[i][k])
    				{
    					map[j][k]=map[j][i]+map[i][k];
    				}
    			}
    		}
    	}
    }
    int main()
    {
    	int n,m,i,j,a,b,c;
    	while(~scanf("%d%d",&n,&m))
    	{
    		memset(map,0,sizeof(map));
    		for(i=0;i<=n;i++)
    		{
    			for(j=0;j<=n;j++)
    			{
    				if(i!=j)
    				{
    					map[i][j] = INF;
    				}
    				else
    				{
    					map[i][j] = 0;
    				}
    			}
    		}
    		for(i=0;i<m;i++)
    		{
    			scanf("%d %d %d",&a,&b,&c);
                             if(map[a][b]>c)
    			map[a][b] = map[b][a] = c;
    		}
    		Fory(n);
    		printf("%d\n",map[n][1]);
    	}
    	return 0;
    }
    

算法二：地杰斯塔啦算法（英文名 dijisitela（英文名太长了，我背不过啊，还是用拼音好）)逃）。

其实吧，这个算法一直没有看懂，总觉得有点地方，脑海里模拟不出来，昨天晚上硬怼着模板巧了2遍，今晚上再拿出来的时候，我的天呢，我竟然看懂了。幸福来的太突然了…………

不啰嗦，赶紧写博客，把理解的给记下来。  

其实，我觉得这个算法和上面那个算法 还是有很大的相似度的。

我先把这个题目的过程模拟一边吧。

首选 把访问数组 的起始点 vis[1]=1， 给标记了 以后不在找他。

然后 dist[i] 就代表了 从起始点1 到 其他各个点的距离了。 如果没有路， 距离是 INF（无穷，下面不解释了）。

然后 从 第二个点开始 ，逐个找于第二点 有路，并且 没有访问过的 最短路径的点 ，假设 为 k。然后 便利k 可以到的所有的点 j（1<= j <=
n），如果 dist[j] (表示 初始点 到点j 的距离) 比 dist[k] + map[k][j](表示 从初始点 到点k 然后加上k到 j 的路径)
大， 那么 更新dist[j]= 小的那个（后者）。

这样 从第二个点 一直找到 地 n个点，就可以得到 最短的 到第n 个点的路了。  

    
    
    #include <iostream>
    #include <cstring>
    #include <cstdio>
    #include <queue>
    # define inf 0x3f3f3f3f
    #include<algorithm>
    using namespace std;
    int map[150][150];
    int  dist[150];
    int vis[150];
    int n,m;
    void djskl()
    {
        int i,j,k;
        for(i=1; i<=n; i++)
        {
            dist[i]=map[1][i];
        }
        vis[1]=1;
        for(i=2; i<=n; i++)
        {
            int mmin=inf;
            for(j=1; j<=n; j++)
            {
                if(mmin>dist[j] && !vis[j])
                {
                    mmin=dist[j];
                    k=j;
                }
            }
            vis[k]=1;
            for(j=1; j<=n; j++)
            {
                if(!vis[j] && map[k][j]!=inf)
                {
                    if(dist[j]>dist[k]+map[k][j])
                    {
                        dist[j]=dist[k]+map[k][j];
                    }
                }
            }
        }
        cout<<dist[n]<<endl;
    }
    int main ()
    {
        int i,j;
        while (cin >>n>>m)
        {
            memset(vis,0,sizeof(vis));
            memset(dist,0,sizeof(dist));
            for(i=1; i<=n; i++)
            {
                for(j=1; j<=n; j++)
                {
                    if(i==j) map[i][j]=0;
                    else map[i][j]=inf;
                }
            }
            int a,b,c;
            for(i=0; i<m; i++)
            {
                cin >>a>>b>>c;
                if(map[a][b]>c)
                    map[a][b]=map[b][a]=c;
            }
            djskl();
        }
        return 0;
    }
    

  

