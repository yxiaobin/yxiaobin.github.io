---
title: 数据结构实验之图论四：迷宫探索
date: 2017-06-12 17:14:55
categories: 数据结构文章标签
---
有一个地下迷宫，它的通道都是直的，而通道所有交叉点(包括通道的端点)上都有一盏灯和一个开关；请问如何从某个起点开始在迷宫中点亮所有的灯并回到起点？  
Input  
  
连续T组数据输入，每组数据第一行给出三个正整数，分别表示地下迷宫的结点数N(1 < N <= 1000)、边数M(M <=
3000)和起始结点编号S，随后M行对应M条边，每行给出一对正整数，表示一条边相关联的两个顶点的编号。<!-- more -->  
  
Output  
  
若可以点亮所有结点的灯，则输出从S开始并以S结束的序列，序列中相邻的顶点一定有边，否则只输出部分点亮的灯的结点序列，最后输出0，表示此迷宫不是连通图。  
访问顶点时约定以编号小的结点优先的次序访问，点亮所有可以点亮的灯后，以原路返回的方式回到起点。  
Example Input  
  
1  
6 8 1  
1 2  
2 3  
3 4  
4 5  
5 6  
6 4  
3 6  
1 5  
  
Example Output  
  

1 2 3 4 5 6 5 4 3 2 1

首选，从起始点开始找到可以便利整个图的一条路，这是一个dfs。  

  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    #include <algorithm>
    using namespace std;
    int m,k,t,p;
    int mp[1200][1200];
    int vis[1200];
    int ans[3000];
    
    void dfs(int x)
    {
        vis[x]=1;
        ans[p++]=x;
        for(int i=1; i<=k; i++)
        {
            if(!vis[i] && mp[x][i])
            {
               dfs(i);
               ans[p++]=x;// 很重要，这里存储的是x 不是i，存储的是他返回的路，如果这里没有理解，说明你的递归还存在问题。
            }
    
        }
    
    }
    int main ()
    {
        int n,i,x,y;
        scanf("%d",&n);
        while(n--)
        {
            memset(mp,0,sizeof(mp));
            memset(vis,0,sizeof(vis));
            scanf("%d %d %d",&k,&m,&t);
            for(i=0; i<m; i++)
            {
                scanf("%d %d",&x,&y);
                mp[x][y]=mp[y][x]=1;
            }
            p=0;
            dfs(t);
            for(i=0;i<p;i++)
            {
                if(i==0) cout<<ans[i];
                else cout<<" "<<ans[i];
            }
            if(p!=2*k-1) printf(" 0");// 除了最后一个点存储了一次意外，其他的点都经过了两次。
            printf("\n");
        }
        return 0;
        }
    
    
    /***************************************************
    User name: *********
    Result: Accepted
    Take time: 4ms
    Take Memory: 1760KB
    Submit time: ********
    ****************************************************/

  
  

