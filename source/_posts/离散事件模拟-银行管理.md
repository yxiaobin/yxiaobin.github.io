---
title: 离散事件模拟-银行管理
date: 2017-06-01 21:43:33
categories: 数据结构文章标签
---
  
离散事件模拟-银行管理  
Time Limit: 1000MS Memory Limit: 65536KB  
Problem Description  
  
  
  
现在银行已经很普遍，每个人总会去银行办理业务，一个好的银行是要考虑 平均逗留时间的，即： 在一定时间段内所有办理业务的人员逗留的时间的和/
总的人数。逗留时间定义为 人员离开的时间减去人员来的时间。银行只有考虑了这一点<!-- more -->，我们在办理业务的时候，才不会等太多的时间。  
  
为了简化问题，我们认为银行只有一号窗口和二号窗口可以办理业务
，并且在时间范围是12<=time<=18,即从中午十二点到晚上十八点，输入数据采用分钟即0代表中午12点，60代表下午一点，90代表下午一点半…
这样time>=0&&time<=360,
如果来的时间超出这个时间段不接受（办理时间不受限制）。每个人到达的时间都不一样。顾客到达的时候，总是前往人数少的那个窗口。如果人数相当或者两个窗口都没有人总是前往1号窗口。请计算平均逗留时间=总逗留的分钟数/总的人数。  
Input  
  
  
  
第一行一个整数t(0 < t <= 100), 代表输入的组数。  
  
对于每一组输入一个整数n (0 < n <= 100)，代表有n个人。然后是n行，每行有两个数据 x 与 y。
x代表顾客到达时间，y代表办理业务需要的时间。x, y 为整数（0 <= x <= 360）(y > 0 && y <=
15)。数据保证按顾客来的先后顺序输入。  
Output  
  
  
  
对于每组数据输出平均逗留时间，保留两位小数。  
Example Input  
  
1  
1  
60 10  
  
Example Output  
  
10.00  

提示 ： RE了10发左右，问题在于 i！=0 的时候， pop队列的时候老是出现问题。

题意最重要的一点是，某一个人的逗留时间是他走的时间减去他来的时间（因为，他可能会排队…………）而他走的时间就要取决于前面一个人离开的时间，在前面的人离开的时间的基础上加上本人的逗留时间就是该人离开的时间。用一个数组把这个队伍中所有人离开的时间全部记路下来，这样就可一很容易的找到前一个人的离开时间了。  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    #include<algorithm>
    using namespace std;
    int a[1500];
    int b[1500];
    queue <int>p;
    queue <int>q;
    int main()
    
    {
        int n,i,t;
        int k[150], j[150],kx,jx;//记录 离开的时间
        cin >>t;
        while(t--)
        {
            while (!q.empty())//清空栈
                q.pop();
            while (!p.empty())
                p.pop();
            cin >> n;
            int  sum=0;
            int  ans=0;
            kx=jx=0;
            for(i=0; i<n; i++)
            {
                cin >>a[i]>>b[i];
                if(i!=0)
                {
                    if(!p.empty())  // 不这么写 报RE
                    {
                        while(p.front()<=a[i])
                        {
                            p.pop();
                            if(p.size()==0) //没这句话 报RE
                             break;
                        }
                    }
                    if(!q.empty())
                    {
                        while(q.front()<=a[i])
                        {
                            q.pop();
                            if(q.size()==0)
                             break;
                        }
                    }
                }
                if(p.size() <= q.size())
                {
                    ans++;//总人数
                    if(p.size()==0)
                    {
                        p.push(b[i]+a[i]);//走的时候的时间
                        k[kx]=b[i]+a[i];//记录 该人离开的时间
                        sum+=b[i];
                    }
                    else
                    {
                        p.push(k[kx]+b[i]);//前面如果有人的话，则该人离开的时间
                        k[kx+1]=k[kx]+b[i];//该人离开的时间
                        kx++;
                        sum+=k[kx]-a[i];
                    }
                }
                else  if(p.size() > q.size())
                {
                    ans++;
                    if(q.size()==0)
                    {
                        q.push(b[i]+a[i]);//走的时候的时间
                        j[jx]=b[i]+a[i];
                        sum+=b[i];
                    }
                    else
                    {
                        q.push(j[jx]+b[i]);
                        j[jx+1]=j[jx]+b[i];
                        jx++;
                        sum+=j[jx]-a[i];
                    }
                }
            }
            double m=0;
            m=(double)sum/(ans*1.0);
            printf("%.2lf\n",m);
        }
        return 0;
    }
    
    

  
  

