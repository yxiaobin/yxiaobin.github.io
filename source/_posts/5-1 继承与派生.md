---
title: 5-1 继承与派生
date: 2017-12-14 19:30:00
categories: 
---
Problem Description  
  
通过本题目的练习可以掌握继承与派生的概念，派生类的定义和使用方法，其中派生类构造函数的定义是重点。  
要求定义一个基类Point，它有两个私有的float型数据成员X,Y;一个构造函数用于对数据成员初始化；有一个成员函数void Move(float
xOff, float yOff)实现分别对X,Y值的改变，其中参数xOff和yOff分别代表偏<!-- more -->移量。另外两个成员函数GetX()
、GetY()分别返回X和Y的值。  
Rectangle类是基类Point的公有派生类。它增加了两个float型的私有数据成员W,H; 增加了两个成员函数float GetH() 、float
GetW()分别返回W和H的值；并定义了自己的构造函数，实现对各个数据成员的初始化。  
编写主函数main()根据以下的输入输出提示，完成整个程序。  
Input  
  
  
6个float型的数据，分别代表矩形的横坐标X、纵坐标Y、宽度W，高度H、横向偏移量的值、纵向偏移量的值；每个数据之间用一个空格间隔  
Output  
  
  
输出数据共有4个，每个数据之间用一个空格间隔。分别代表偏移以后的矩形的横坐标X、纵坐标Y、宽度W，高度H的值  
Example Input  
  
5 6 2 3 1 2  
Example Output  
  
6 8 2 3  
Hint  
  
输入 -5 -6 -2 -3 2 10  

输出 -3 4 0 0

  

    
    
    #include <iostream>
    #include <cmath>
    using namespace std;
    class Point
    {
    private:
        double x,y;
    public:
        Point(double j=0 , double k = 0):x(j),y(k)
    {
    
    }
        void Move(double xOff, double yOff)
        {
            x = x+xOff;
            y = y+yOff;
        }
        double getx()
        {
            return x;
        }
        double gety()
        {
            return y;
        }
    };
    class Rectangle : public Point
    {
    private:
        double w, h;
    public:
        Rectangle(double j=0 , double k = 0, double m =0, double n = 0):Point(j,k)
        {
            if(m<0) m=0;//Hint 中提示了这种情况即宽和高应该符合实际问题（大于等于0）
            if(n<0) n=0;
            w = m;
            h = n;
        }
        double getw()
        {
            return w;
        }
        double geth()
        {
            return h;
        }
    
    };
    int main ()
    {
        double a,b,c,d,e,f;
        cin>>a>>b>>c>>d>>e>>f;
        Rectangle s1(a,b,c,d);
        s1.Move(e,f);
       cout<<s1.getx()<<" "<<s1.gety()<<" "<<s1.getw()<<" "<<s1.geth()<<endl;
    }
    

  
  

