---
title: SDUT-山峰---栈的单步调用
date: 2017-07-24 20:24:00
categories: 数据结构文章标签
---
  
  
金石山脉有n个山峰，一字排开，从西向东依次编号为1, 2, 3, ……, n。编号为i的山峰高度为hi。每个山峰的高度两两不同  
  
小木示从西向东依次爬过这n个山峰，到每一个山峰的山顶的时候，他都会往西边眺望，并且会记录下自己能看到的山峰的个数。  
（比如说小木示 现在在4号山峰，前四号山峰的高度分别为9,4,5,1。他现在能看到的山峰个数就是2,因为第二个山峰被第三个山峰挡住<!-- more -->了）  
  
严格的来说，小木示在i位置的时候，对于一个山峰j (j < i)，如果不存在一个山峰k满足hj < hk (j < k < i)。则山峰j是可见的。  
  
小木示把自己记录的山峰的个数加和作为这次爬山的快乐值，现在给你n个山峰的高度，求小木示的快乐值。  
Input  
  
多组输入，首先输入一个n（1 <= n <= 10^6）,表示山峰的个数。  
  
接下来一行n个数，表示对应山峰的山峰的高度(1 <= h <= 10^6)。  
Output  
  
输出小木示的快乐值  
Example Input  
  
4  
1 6 5 1  
  
Example Output  
  
4  

思路：

1\. 假设站在第n个山上，那么可以看到的就是从第1个山到第n-1
个山的一个最长的下降序列，一开始的想法是用dp来做，但是没有dp明白，学长说，这是一个赤裸裸的单步调用栈的操作。

2.利用栈的思维来向，每次看山峰的时候，往前看到的是越来越高的，越往前的山峰应该越高，把他看成一个堆栈的时候，那么栈底的元素应该是最大的，栈顶的元素应该是最小的，现在给定一组数，先把第一个数压进栈里面，从第二个数读取开始累加
每当进行读取操作时候，栈里面元素的数量。（相当于前一个状态下，从开始到此点的下降元素的个数），然后讲栈中元素从栈顶开始一次与读取的数据比较，讲比该读取的元素数值小的全部压出栈（对于第n+1
座山来说， 比第n座山矮的全部看不见），再讲该读取元素入栈，重复此操作。

3\. cin 读取会超市

4\. 数据范围过大， 求和应该用 long long 类型

  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <stack>
    #include <algorithm>
    using namespace std;
    
    int main()
    {
        int n,i,j;
        long long sum;
        while(~scanf("%d",&n))
        {
            stack<int>q;
            sum=0;
            scanf("%d",&j);
            q.push(j);
            for(i=1;i<n;i++)
            {
              scanf("%d",&j);
              sum+=q.size();
              while(!q.empty() && j>q.top())
              {
                q.pop();
              }
              q.push(j);
            }
           cout<<sum<<endl;
        }
    }
    

  
  

  

  

