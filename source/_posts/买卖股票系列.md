---
title: 买卖股票系列
date: 2022-03-09 21:20:31
tags: leetcode
---

[toc]



#  1.[买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

* 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

  返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

* 示例

  ```
  输入：[7,1,5,3,6,4]
  输出：5
  解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =5。
  注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
  
  ```

  <!-- more -->

* 方法：

  ```java
  /*
  * 只能进行一次买和卖，那么可能的收益就是第i天的股票价格-第[0,i-1]天中股票的最低价格。
  * 设置一个变量curmin，维护到第i-1天的最低价格，枚举即可。
  */
  class Solution {
      public int maxProfit(int[] a) {
          int res = 0;
          int curmin = a[0];
          for(int i=1;i <a.length; i++){
              res =Math.max(res, a[i] - curmin);
              curmin= Math.min(curmin,a[i]);
          }
          return res;
      }
  }
  ```

  

# 2.[买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

* 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

  返回 你能获得的 最大 利润 。

* 示例

  ```
  输入：prices = [7,1,5,3,6,4]
  输出：7
  解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
  随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
  总利润为 4 + 3 = 7 。
  ```

  ```
  输入：prices = [1,2,3,4,5]
  输出：4
  解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
  总利润为 4 。
  ```

  ```
  输入：prices = [7,6,4,3,1]
  输出：0
  解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
  ```

* 方法

  ```java
  /*
  * 动态规划，维持状态，0表示今天操作完以后手里没有股票，1表示今天操作完手里有股票
  */
  class Solution {
      public int maxProfit(int[] a) {
          int n = a.length;
          /*
          * dp[i][0] 手中没有股票。
          * dp[i][1] 手中持有股票。
          */
          int[][] dp = new int[n][2];
          //init
          dp[0][0] = 0;
          dp[0][1] = -a[0];
          for(int i=1; i<n; i++){
              //今天没有股票有两种情况：1.昨天持有股票，今天卖掉了。2.或者昨天就没有股票。
              dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+a[i] );
              dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-a[i]);
              //今天有股票有两种情况：1.昨天持有股票。2.或者昨天没有股票，今天买的。
          }
          //很明显 最后一天手里没有股票才有可能是最大收益
          return dp[n-1][0];
      }
  }
  ```

  

# 3.[买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

* 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

  设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

  

* 示例

  ```
  输入：prices = [3,3,5,0,0,3,1,4]
  输出：6
  解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3。
  随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
  
  ```

  ```
  输入：prices = [1,2,3,4,5]
  输出：4
  解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
  注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
  因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
  ```

  ```
  输入：prices = [7,6,4,3,1] 
  输出：0 
  解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
  ```

  ```
  输入：prices = [1]
  输出：0
  ```

* 方法

  ```java
  class Solution {
      public int maxProfit(int[] a) {
           int n = a.length;
          /*
          * dp[i][0] 手中持有股票1
          * dp[i][1] 手中没有股票1。
          * dp[i][2] 手中持有股票2。
          * dp[i][3] 手中没有股票2。
          */
          int[][] dp = new int[n][4];
          //init
          dp[0][0] =  -a[0];
          dp[0][2] = -a[0];
          for(int i=1; i<n; i++){
  
              //0：手中持有股票1: 昨天就持有股票1 + 昨天没有股票，今天刚买的(没有股票1前的收益全都是0)
              dp[i][0] = Math.max(dp[i-1][0],-a[i]);
  
              //1：手中没有股票1: 昨天就没有股票1 + 昨天还持有第一个股票，今天卖的
              dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]+a[i]);
  
              //2：手中持有股票2: 昨天就持有股票2 + 昨天没有股票1，今天刚买的股票2
              dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]-a[i] );
  
              //3：手中没有股票2: 昨天就没有股票2 + 昨天还持有股票2，今天卖的股票2
              dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]+a[i]);
                       
          }
          //很明显 最后一天手里没有股票才有可能是最大收益
          return dp[n-1][3];
      }
  }
  ```

  

# 4.[买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

* 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

  设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

* 示例

  ```
  输入：k = 2, prices = [2,4,1]
  输出：2
  解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
  ```

  ```
  输入：k = 2, prices = [3,2,6,5,0,3]
  输出：7
  解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
       随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
  ```

  

* 方法：**和上一题思路一样，只不过变成k罢了**

  ```java
  class Solution {
      public int maxProfit(int k, int[] a) {
          int n = a.length;
          if(n==0 || k==0) return 0;
          int dp[][] = new int[n][2*k];
          /*
          * init
          * i%2 = 0; 手中持有股票
          * i%2 = 1; 手中没有股票
          */ 
          for(int i=0;i<2*k;i++){
              if(i%2==0){
                  dp[0][i] = -a[0];
              }
          }
          for(int i=1; i<n;i++){
              for(int j=0; j<2*k;j++){
                  //手中持有股票
                  if(j%2==0){
                      if(j==0){
                          //前一天就持有股票，或者第一次持有股票
                          dp[i][j] = Math.max(dp[i-1][j], -a[i]);
                      }else{
                          //前一天就持有股票，或者已经卖掉一次股票，重新买入
                          dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1]-a[i]);
                      }
                  }else{
                      //手中没有股票
                      //前一天就没有股票，或者手里有当前股票，卖掉
                      dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1]+a[i]);
                  }
              }
          }
          return dp[n-1][2*k-1];
      }
  }
  ```

  

# 5.[最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

* 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

  设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

  卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

* 示例

  ```
  输入: prices = [1,2,3,0,2]
  输出: 3 
  解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
  ```

  ```
  输入: prices = [1]
  输出: 0
  ```

  

* 方法

  ```java
  class Solution {
      public int maxProfit(int[] a) {
          int n = a.length;
          /*
          * dp表示的是今天操作完，即将进入的状态。
          * dp[i][0] 手里没有股票，非冷冻期
          * dp[i][1] 手里刚买入股票
          * dp[i][2] 手里没有股票，冷冻期
          */
          int dp[][] = new int[n][3];
          //init
          dp[0][0] = 0;
          dp[0][1] = - a[0];
          dp[0][2] = 0;
  
          for(int i=1; i<n; i++){
              //手里没有股票，非冷冻期： 昨天就没有股票，非冷冻期 + 昨天没有股票，冷冻期。
              dp[i][0] = Math.max(dp[i-1][0],dp[i-1][2]);
  
              //手里有股票： 昨天有股票 + 昨天没有股票，今天买入，则昨天是非冷冻期。
              dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-a[i]);
              
              //手里没有股票，冷冻期： 昨天卖掉股票。
              dp[i][2] = dp[i][1]+a[i];
          }
          return Math.max(dp[n-1][0], dp[n-1][2]);
      }
  }
  ```

  

# 6.[买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

* 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

  你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

  返回获得利润的最大值。

  注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

* 示例

  ```
  输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
  输出：8
  解释：能够达到的最大利润:  
  在此处买入 prices[0] = 1
  在此处卖出 prices[3] = 8
  在此处买入 prices[4] = 4
  在此处卖出 prices[5] = 9
  总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
  
  ```

  ```
  输入：prices = [1,3,7,5,10,3], fee = 3
  输出：6
  ```

* 方法

  ```java
  class Solution {
      public int maxProfit(int[] a, int fee) {
          int n = a.length;
          /*
          * dp[i][0] 手中没有股票。
          * dp[i][1] 手中持有股票。
          * ### 注意每次卖出的时候需要减掉fee
          */
          int[][] dp = new int[n][2];
          //init
          dp[0][0] = 0;
          dp[0][1] = -a[0];
          for(int i=1; i<n; i++){
              //今天没有股票有两种情况：1.昨天持有股票，今天卖掉了。2.或者昨天就没有股票。
              dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+a[i]-fee);
              dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-a[i]);
              //今天有股票有两种情况：1.昨天持有股票。2.或者昨天没有股票，今天买的。
          }
          //很明显 最后一天手里没有股票才有可能是最大收益
          return dp[n-1][0];
      }
  }
  ```

  

  

# 7.参考链接

[股票问题系列通解（转载翻译） - 力扣（LeetCode）](https://leetcode.cn/circle/article/qiAgHn/)