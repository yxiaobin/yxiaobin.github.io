---
title: 通过余弦相似度找物品之间的联系
date: 2020-05-15 11:04:37
categories: 数据结构文章标签
---
  * 由于毕设用到了推荐算法，这几天在搜索资料，对基于项目的协同过滤算法有了一定的理解，我的理解就是“物以类聚”。通过所有用户对某一商品的评分，来寻找商品之间的相似度。在这里我用的是利用求余弦的方式来判别。 
  * 程序主要解决了2个问题 
    * 1、评分中心化:不同的用户打分喜好不同，有的人喜欢打高分，例如喜欢打5分不喜欢打3分，有的人喜欢打低分，例如喜欢打4分不喜欢打1分，这样对数据<!-- more -->是有影响的，因此需要平分中心化。除此之外对于一个用户他没有评价的商品，默认为0，这个0有着极大的不喜欢的意义，这对于数据的分析也有影响，我们要想办法，把这个默认0设定为一个中性的，既不影响喜欢的程度，也不影响不喜欢的程度。 
    * 2、实现余弦求相似度的计算：简单的一个向量点乘坐标计算实现的公式，不难。 

    
    
    		#include <iostream>
    		#include <math.h>
    		using namespace std;
    		
    		double item[100][100];
    		double value[100][100];
    		double consin[100][100];
    		
    		void get_cos(int x,int y)
    		{
    		    //计算a点乘b
    		    double a=0;
    		    for(int i=1; i<6; i++)
    		        a += value[i][x]*value[i][y];
    		    //计算 a，b 的模长
    		    double b=0, c=0  ;
    		    for(int i=1; i<6; i++)
    		    {
    		        b += pow(value[i][x],2);
    		        c += pow(value[i][y],2);
    		    }
    		
    		    //开根号
    		    b = sqrt(b);
    		    c = sqrt(c);
    		    consin[x][y] = a/(b*c);
    		}
    		
    		int main()
    		{
    		    cout<<"现假设有用户5人，商品五个，请随机输入部分用户对部分物品的评分"<<endl;
    		    for(int i=1; i<6; i++)
    		        for(int j=1; j<6; j++)
    		            cin>>item[i][j];
    		    cout<<"用户的评分表如下"<<endl;
    		    cout<<"用户\t物品1\t物品2\t物品3\t物品4\t物品5"<<endl;
    		    for(int i=1; i<6; i++)
    		    {
    		        cout<<"用户"<<i<<"\t";
    		        for(int j=1; j<6; j++)
    		        {
    		            cout<<item[i][j]<<"\t";
    		        }
    		        cout<<endl;
    		    }
    		    cout<<"用户商品评分中心化"<<endl;
    		    for(int i=1; i<6; i++)
    		    {
    		        double sum = 0;
    		        int n = 0;
    		        for(int j=1; j<6; j++)
    		        {
    		            sum +=item[i][j];
    		            if(item[i][j] >0)
    		                n++;
    		        }
    		
    		        if(sum==0) sum = 0;
    		        else
    		        {
    		            sum = sum/(n*1.0);
    		        }
    		        for(int j=1; j<6; j++)
    		            if(item[i][j] > 0)
    		                value[i][j] =item[i][j] - sum;
    		    }
    		    cout<<"用户的评分表如下"<<endl;
    		    cout<<"用户\t物品1\t物品2\t物品3\t物品4\t物品5"<<endl;
    		    for(int i=1; i<6; i++)
    		    {
    		        cout<<"用户"<<i<<"\t";
    		        for(int j=1; j<6; j++)
    		        {
    		            cout<<value[i][j]<<"\t";
    		        }
    		        cout<<endl;
    		    }
    		    cout<<"正在进行物品相似度计算。。。。。。。"<<endl;
    		    for(int i=1; i<=5; i++)
    		    {
    		        for(int j=1; j<=5; j++)
    		            get_cos(i,j);
    		    }
    		
    		    cout<<"物品的相似度表如下"<<endl;
    		    cout<<"物品\t物品1\t物品2\t物品3\t物品4\t物品5"<<endl;
    		    for(int i=1; i<6; i++)
    		    {
    		        cout<<"物品"<<i<<"\t";
    		        for(int j=1; j<6; j++)
    		        {
    		            cout<<consin[i][j]<<"\t";
    		        }
    		        cout<<endl;
    		    }
    		}
    
    

![程序的运行结果](https://img-blog.csdnimg.cn/20200515105949567.png?x-oss-
process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODA2NDgxMA==,size_16,color_FFFFFF,t_70)

  * 已知对于两个向量a,b，当向量相等时，其夹角为0，余弦值为1，向量相反时，夹角为π，余弦值为-1，故当两个物品相似度越高的时候，他们的余弦值越大，如图所示，物品1和物品2有着极大的相似度，物品4和物品5有着极大的相似，因此对于购买物品1没有购买物品2的用户就可以将物品2推荐给他。 

