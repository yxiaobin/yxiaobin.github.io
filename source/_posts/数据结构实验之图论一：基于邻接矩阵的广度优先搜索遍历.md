---
title: 数据结构实验之图论一：基于邻接矩阵的广度优先搜索遍历
date: 2017-06-03 20:14:23
categories: 数据结构文章标签
---
数据结构实验之图论一：基于邻接矩阵的广度优先搜索遍历  
Time Limit: 1000MS Memory Limit: 65536KB  
Problem Description  
  
给定一个无向连通图，顶点编号从0到n-1，用广度优先搜索(BFS)遍历，输出从某个顶点出发的遍历序列。(同一个结点的同层邻接点，节点编号小的优先遍历）  
Input  
  
输入第一行为整数n（0< n<!-- more --> <100），表示数据的组数。  
对于每组数据，第一行是三个整数k，m，t（0＜k＜100，0＜m＜(k-1)*k/2，0＜ t＜k），表示有m条边，k个顶点，t为遍历的起始顶点。  
下面的m行，每行是空格隔开的两个整数u，v，表示一条连接u，v顶点的无向边。  
Output  
  
输出有n行，对应n组输出，每行为用空格隔开的k个整数，对应一组数据，表示BFS的遍历结果。  
Example Input  
  
1  
6 7 0  
0 3  
0 4  
1 4  
1 5  
2 3  
2 4  
3 5  
  
Example Output  
  

0 3 4 2 5 1

思路：

之前就听小伙伴们在不断的吐槽 bfs 和 dfs
最短路什么又麻烦，又抽象，渣渣的我的进度也终于到了bfs，dfs了（沉浸于被大佬支配的恐惧中…………）。首选 bfs 是
按照层的顺序进行搜索的一层一层的进行查找，他运用了队列，即
将与a联通的所有bcd进入队列中，在逐个从队列中出来，把与他们相联通的在进入队列中，直到队列为空的时候结束。

这就是bfs的理论。而 这道题 相当于又添加了一个条件 那就是 在 查找中 按从小到大查找，我们用循环本来就是从小到大查找的，所以不用担心这个附加条件。  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue> //STL中自带的队列函数，比自己手写的简单多了，不会的快去百度，水题必备
    #include <algorithm>
    using namespace std;
    int m,k,t,p;
    int map[200][200];//邻接矩阵 表示两点之间是否存在路
    int vis[200];//visit 的缩写，代表是否经历过这一个点，标记这个点是否已经搜索过了。
    int ans[200];//储存输出的时候的顺序
    void bfs(int t)
    {
       queue<int >q; // 构建队列，<int > 代表 队列 里面储存的为整形
       vis[t]=1;//标记这个点，不然的话，会在下面的循环中重复扫描这个点。
       ans[p]=t;
       p++;
       q.push(t);
       while(!q.empty())
       {
        int x=q.front();//从队列中取出第一个点，，在下面的循环中，寻找和这个点联通的其余的点
        q.pop();//队列中删除取出的这个点
        for(int i=0;i<k;i++)
        {
            if(map[x][i]==1 && vis[i]!=1)
            {
                vis[i]=1;
                ans[p]=i;
                p++;
                q.push(i); // 找到与所取的点的联通点，并且吧他们标记vis【i】为1，同时让他们入队。
            }
        }
       }
    }
    int main ()
    {
        int n,i,x,y;
        scanf("%d",&n);
        while(n--)
        {
            memset(map,0,sizeof(map));
            memset(vis,0,sizeof(vis));
            scanf("%d %d %d",&k,&m,&t);
            for(i=0;i<m;i++)
            {
                scanf("%d %d",&x,&y);
                map[x][y]=map[y][x]=1;
            }
            p=0;
            bfs(t);
            for(i=0;i<p;i++)
            {
                printf("%d%c",ans[i],i==p-1?'\n':' ');
            }
        }
    
    }
    

  
  

  

