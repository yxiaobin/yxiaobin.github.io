---
title: 数据结构实验之栈二：一般算术表达式转换成后缀式
date: 2017-06-01 19:30:04
categories: 数据结构文章标签
---
Time Limit: 1000MS Memory Limit: 65536KB  
Problem Description  
对于一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出之。  
Input  
输入一个算术表达式，以‘#’字符作为结束标志。  
Output  
输出该表达式转换所得到的后缀式。  
Example Input  
  
a*b+(c-d/e)*f#  
 <!-- more --> 
Example Output  
  

ab*cde/-f*+

2017.10 OJ数据加强后代码已经更新，且保留原始漏洞代码进行比对

思路 ： 中缀表达式 转化成为 后缀表达式 方法如下。

根据优先顺序可以知道先算乘法，后算加法。若果出现 a*b+c 的情况 后缀表达式应该是 ab*c+。 可以推出来 如果当前的运算符号 的优先级 比
栈里面的优先级小，那么就需要把栈里面所有比当前运算符优先级高的运算符号逐个输出，并且从栈里删除。

如果出现了括号的话，那么需要先对括号里面的算式作为一个单独的算式输出完毕后 在把它放到整个大的算式里逐个输出。  

    
    
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <stack>
    #include<algorithm>
    using namespace std;
    int a[150];
    int main()
    {
        stack <char > q;
        int n,i;
        char s[150];
        cin >> s;
        n=strlen(s);
        for(i=0; i<n; i++)
        {
            if(s[i]!='#')
            {
                if(s[i]>='a' && s[i]<='z')//遇到 字母 直接输出
                {
                    printf("%c",s[i]);
                }
                else if(s[i]=='(')//左括号入栈
                {
                    q.push(s[i]);
                }
                else if (s[i]==')')
                {
                    while(q.top()!= '(')//左括号之前的所有运算符全部出栈
                    {
                        cout << q.top();
                        q.pop();
                    }
                    q.pop();
                }
                else if (s[i]=='*' || s[i]=='/')
                {
                    q.push(s[i]);// 乘除入栈
    
                }
                else if(s[i]=='+'||s[i]=='-')
                {
                    while (!q.empty()&& q.top()!='(' &&(q.top()=='*'||q.top()=='/')) // 栈中 比 + - 优先级高级的率先出栈
                    {
                        cout <<q.top();
                        q.pop();
                    }
                    q.push(s[i]);
    
                }
            }
            else
            {
                break;
            }
        }
        while (!q.empty()) //栈中没出栈的出栈
        {
            cout << q.top();
            q.pop();
        }
        return 0;
    }
    

//2017.10.15 由于后台数据更新，数据加强，上述代码出现bug，具体bug为：

a+b-c 输出 abc-+

a*b/c 输出 abc/*

抽象数据类型栈操作修改代码如下

    
    
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #define  initsize 100
    #define  add      10
    typedef char elemtype;
    typedef int status;
    
    typedef struct
    {
        elemtype *base;
        elemtype *top;
        int stacksize;
    } sqstack;
    void initstack(sqstack &s)
    {
        s.base = (elemtype *) malloc((initsize)* sizeof(elemtype));
        s.top=s.base;
        s.stacksize = initsize;
    }
    void  push(sqstack &s, elemtype e)
    {
        if(s.top - s.base >= s.stacksize)
        {
            s.base = (elemtype *) realloc(s.base, (initsize  + add) * sizeof(elemtype));
            s.top = s.base + s.stacksize;
            s.stacksize +=add;
        }
        *s.top++ =e;
    }
    status pop (sqstack &s)
    {
        if(s.base == s. top) return 0;
        else
        {
            s.top--;
            return *s.top;
        }
    
    }
    char gettop(sqstack &s)
    {
        if(s.base == s.top) return false;
        else
            return *(s.top-1);
    }
    status isempty(sqstack &s)
    {
        if(s.base ==s.top ) return 1;
        else return 0;
    }
    int main()
    {
        char a[100100];
        scanf("%s",a);
        sqstack s;
        initstack(s);
        int n= strlen(a);
        for(int i=0; i<n; i++)
        {
            if(a[i] =='#') break;
            else
            {
                if(a[i] >='a' && a[i] <='z')
                {
                    printf("%c",a[i]);
                }
                else if(a[i] == '(')
                {
                    push(s, a[i]);
                }
                else if(a[i] ==')')
                {
                    while(gettop(s) !='(')
                    {
                        printf("%c",gettop(s));
                        pop(s);
                    }
                    pop(s);
                }
                else if (a[i] == '*' ||a[i] == '/')
                {
                    if(!isempty(s))
                    {
                        if(gettop(s)=='*' ||gettop(s) == '/')
                        {
                            printf("%c",gettop(s));
                            pop(s);
                        }
                    }
                    push(s,a[i]);
                }
                else if(a[i] == '+' ||a[i] == '-')
                {
                    while (!isempty(s) && gettop(s) !='(')
                    {
                        printf("%c",gettop(s));
                        pop(s);
                    }
                    push(s,a[i]);
                }
            }
        }
        while (!isempty(s))
        {
            printf("%c",gettop(s));
            pop(s);
        }
        printf("\n");
        return 0;
    
    }
    
    

  
  

  

