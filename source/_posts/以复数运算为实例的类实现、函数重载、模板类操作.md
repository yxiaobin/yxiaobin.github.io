---
title: 以复数运算为实例的类实现、函数重载、模板类操作
date: 2017-12-09 19:05:50
categories: 
---
首选，我们利用类来实现复数的加法，这不是我们讨论的重点，代码直接给出：

    
    
    #include <iostream>
    using namespace std;
    class complexx
    {
    public:
        complexx(int j=0 ,int k=0)//构造函数
        {
            x=j;<!-- more -->
            y=k;
        }
        complexx add(complexx &b)//相加函数
        {
            complexx tmp;
            tmp.x = x+b.x;
            tmp.y = y+b.y;
            return tmp;
        }
        void show() //输出函数
        {
            cout<<x<<" + "<<y<<"i"<<endl;
        }
    private:
        int x,y;
    };
    int main ()
    {
        complexx a(1,2);
        complexx b(2,3);
        complexx c;
        c = a.add(b);
        c.show();
    }

上述代码实现了 复数1+2i 和 2+3i的 加法运算，他调用了 类中方的 add
以及show函数，下列我们想通过重载符号运算+自动实现相加，以及重载运算符号<<实现输出。

重载操错符用到了关键字 operator ，

对于类成员，非类成员的operator操作，详见blog

https://www.cnblogs.com/hustcser/p/4173758.html  

先摘抄一些关键知识点：

对于全局重载操作符，代表左操作数的参数必须被显式指定 如：

    
    
    bool operator==(person const &p1 ,person const & p2)

  

如何决定把一个操作符重载为类成员函数还是全局名字空间的成员呢？

①如果一个重载操作符是类成员，那么只有当与他一起使用的左操作数是该类的对象时，该操作符才会被调用。如果该操作符的左操作数必须是其他的类型，则操作符必须被重载为全局名字空间的成员。

②C++要求赋值=，下标[]，调用()， 和成员指向-> 操作符必须被定义为类成员操作符。任何把这些操作符定义为名字空间成员的定义都会被标记为编译时刻错误。

③如果有一个操作数是类类型如string类的情形那么对于对称操作符比如等于操作符最好定义为全局名字空间成员。

  

代码如下

    
    
    #include <iostream>
    using namespace std;
    class complexx
    {
    public:
        int Real,Virtual;
        complexx(int x=0, int y=0)//构造函数
        {
            Real = x;
            Virtual = y ;
        }
        complexx operator+ (complexx &ee)// 对加号进行重载， 参数方法为引用，加号返回的类型为complexx
        {
            complexx c;
            c.Real =Real + ee.Real;
            c.Virtual = Virtual + ee.Virtual;
            return c;
        }
        friend ostream& operator<<(ostream& out, const complexx &c)//输出方法为c++模板库的，只能通过友元的连接方式进行重载
        {
            out<<c.Real<<" + "<<c.Virtual<<"i"<<endl;
            return out ; //千万别忘了返回 out
        }
    };
    int main()
    {
        complexx elem1(1,2);
        complexx elem2(3,4);
        complexx  c;
        c= elem1 + elem2;
        cout<<c;
    }

将其封装为一个模板类，需要调用函数 template声明

代码如下：

    
    
    #include <iostream>
    using namespace std;
    template <class T>
    class complexx
    {
    public:
        T Real,Virtual;
        complexx(T x=0, T y=0)
        {
            Real = x;
            Virtual = y ;
        }
        complexx operator+ (complexx &ee)
        {
            complexx c;
            c.Real =Real + ee.Real;
            c.Virtual = Virtual + ee.Virtual;
            return c;
        }
        friend ostream& operator<<(ostream& out, const complexx &c)
        {
           return out<<c.Real<<" + "<<c.Virtual<<"i"<<endl;
             //千万别忘了返回 out
        }
    };
    int main()
    {
        complexx<float> elem1(1.2,2);// 这里的 类型就必须表达清楚了，写成complexx<T> 就报错了
        complexx<float> elem2(3,4.9);
        complexx<float> c;//这三个的 <T> 类型需要相同
        c= elem1 + elem2;
        cout<<c;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

  
  

