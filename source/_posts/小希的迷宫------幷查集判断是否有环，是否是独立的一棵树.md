---
title: 小希的迷宫------幷查集判断是否有环，是否是独立的一棵树
date: 2017-08-16 10:18:52
categories: 数据结构
---
上次Gardon的迷宫城堡小希玩了很久（见Problem
B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的<!-- more -->设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。  
![](http://acm.hdu.edu.cn/data/images/C20-1007-1.jpg)  

  

Input

输入包含多组数据，每组数据是一个以0
0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。  
整个文件以两个-1结尾。  

  

Output

对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出"Yes"，否则输出"No"。  

  

Sample Input

    
    
      
    
    
       6 8  5 3  5 2  6 4
    5 6  0 0
    
    8 1  7 3  6 2  8 9  7 5
    7 4  7 8  7 6  0 0
    
    3 8  6 8  6 4
    5 3  5 6  5 2  0 0
    
    -1 -1
      

  

Sample Output

    
    
      
    
    
       Yes
    Yes
    No
      

  

    
    
    #include <iostream>
    #include<cstdio>
    #include<cstring>
    #include <algorithm>
    using namespace std;
    int a[100100], flag;
    int vis[100100];
    void Init()
    {
        for(int i=1; i<100100; i++)
        {
            a[i]=i;
            vis[i]=0;
        }
    }
    int get_boss(int x)
    {
        if(a[x]==x) return x;
        else
        {
            a[x]=get_boss(a[x]);
            return a[x];
        }
    }
    void  mergy(int x, int y)
    {
        int t1=get_boss(x);
        int t2=get_boss(y);
        if(t1!=t2)
        {
            if(t1>t2)//找根你需要固定一个原则，我的原则是数值大的是根，是boos
                a[t2]=t1;
            else
                a[t1]=t2;
    
        }
        else//两者有这相同的父节点，同时有把两者联通，这就构成了环
            flag=0;
    }
    int main ()
    {
        int n,m;
        while (scanf("%d %d",&n,&m))
        {
            if(n==-1 && m==-1) break;
            flag=1;
            if(n!=0 && m!=0)
            {
                Init();
                vis[m]=vis[n]=1; // vis数组起到标记的作用，下面统计几棵树的时候用到
                mergy(n,m);
                while(scanf("%d %d",&n,&m), n||m)
                {
                    vis[m]=vis[n]=1;
                    mergy(n,m);
                }
            }
            int cnt=0;
            for(int i=0; i<100100; i++)
            {
                if(vis[i] && a[i]==i)
                    cnt++;
            }
            if(cnt != 1) flag=0;//如果大于一棵树，不合题意，标记变量值改变
            if(flag) printf("Yes\n");
            else printf("No\n");
        }
    }
    
    

  
  

