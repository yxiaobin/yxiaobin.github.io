---
title: 电影节----并查集+一点点思考
date: 2017-08-14 09:41:30
categories: 数据结构
---
某届电影节评选电影，共有两部电影进入最后评选环节，有n名观众，每个人有一次投票的机会，每个人都按照规则投给其中一部电影。为了了解情况，记者随机询问了一些人，一共询问了m次，特别神奇的是，记者每次都询问两个人，而且这两个人都把票投给了同一部电影，观众编号为1~n。  
Input  
多组输入，每组第一行是两个整数n，m (2 <= n <=100000，0 <= m <
n/2)，接下来m行数据，<!-- more -->表示m次询问，每行数据有两个整数a，b代表观众的编号(1 <= a，b <=
n)，观众a和观众b投票给了同一部电影，接下来一行是两个整数c，d(1 <= c，d <= n)。  
Output  
对于每一组输入，输出一行，如果观众c和观众d投票给同一部电影，输出”same”，如果不能确定，输出”not sure”。  
Example Input  
  
5 2  
1 2  
2 3  
1 3  
5 2  
1 2  
3 4  
1 4  
5 2  
1 2  
3 4  
2 5  
  
Example Output  
  
same  
not sure  
not sure  

这是我做的并查集的第二道题目，一开始直接比较a【c】 a【d】
是否相等，wa了好久，于是又去看书，结果发现代码和书上的一样，就是wa，于是又看了一遍啊哈算法的过程，突然注意到，算法那中并不是把全部的他的小兵全部归为他的大boos（有些递归程序太繁琐，严重影响效率），于是，想到了还需要去寻找一遍cd的
最终大boos，看他们的大boos 是否是一个。  

    
    
    #include <stdio.h>
    int a[100100];
    int get_boss(int x)
    {
        if(a[x]==x) return x;
        else
        {
            a[x]=get_boss(a[x]);
            return a[x];
        }
    }
    void mergy(int x,int y)
    {
        int t1,t2;
        t1=get_boss(x);
        t2=get_boss(y);
        if(t1!=t2)
        {
            a[t2]=t1;
        }
        return ;
    }
    
    int main ()
    {
        int n,m,x,y;
        while(~scanf("%d %d",&n,&m))
        {
            for(int i=1; i<=n; i++)
            {
                a[i]=i;
            }
            for(int i=0; i<m; i++)
            {
                scanf("%d %d",&x,&y);
                mergy(x,y);
            }
            scanf("%d %d",&x,&y);
            int p=get_boss(x);//寻找xy的大boos！！
            int q=get_boss(y);
            if(p==q)
            {
                printf("same\n");
            }
            else
                printf("not sure\n");
        }
        return 0;
    }
    

  
  

